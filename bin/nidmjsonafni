#!/usr/bin/python
"""
Export neuroimaging results created with FSL feat following NIDM-Results

DC code convergence
"""
import json
import sys
from subprocess import check_call, check_output
from collections import OrderedDict

# nidmjsonafni ttest++_result+tlrc.BRIK

if __name__ == "__main__":
    # Remove first argument (script name)
    num_args = len(sys.argv)-1
    sys.argv.pop(0)
    args = sys.argv

    usage = "Usage: nidmafni path/to/feat/dir"

    if num_args != 1:
        raise Exception(usage)

    resbrik = args[0]
    print(resbrik)

    nidm = OrderedDict()
    nidm['NeuroimagingAnalysisSoftware'] = {
        "type": "AFNI",
        # Is the version of AFNI that was used for the analysis stored somwhere?
        "softwareVersion": "TODO"
    }

    nidm['Data'] = {
        # TODO rethink in NIDM
        'grandMeanScaling': True,
        'targetIntensity': 100        
    }

    nidm['DesignMatrix'] = {
        'atLocation': "TODO",
        'regressorNames': ["group"]
    }

    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[0]
        '3dAFNItoNIFTI', '-prefix', 'ParameterEstimate', resbrik + '[0]'])
    nidm['ParameterEstimateMap'] = {
        'atLocation': "ParameterEstimate.nii"
    }

    nidm['ErrorModel'] = {
        'hasErrorDistribution': "obo_NormalDistribution",
        'errorVarianceHomogeneous': True,
        # TODO:  check
        'varianceMapWiseDependence': "nidm:IndependentParameter",
        'hasErrorDependence': "nidm:IndependentError",
        'depemdenceMapWiseDependence': "nidm_IndependentParameter"        
    }


    nidm['ModelParameterEstimation'] = {
        'withEstimationMethod': "obo_OrdinaryLeastSquaresEstimation"
    }

    # TODO residualmeansquares
    nidm['ResidualMeanSquaresMap'] = {
        'atLocation': "TODO"
    }
    # TODO GrandMeanMap --> not needed
    nidm['GrandMeanMap'] = {
        'atLocation': "TODO"
    }

    # TODO MaskMap_atLocation
    nidm['MaskMap'] = {
        'atLocation': "TODO"
    }

    # TODO CoordinateSpace_inWorldCoordinateSystem
    nidm['CoordinateSpace'] = {
        'inWorldCoordinateSystem': "TODO"
    }

    nidm['Contrasts'] = []
    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[0]
        '3dAFNItoNIFTI', '-prefix', 'Contrast', resbrik + '[0]'])
    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[1]
        '3dAFNItoNIFTI', '-prefix', 'TStatistic', resbrik + '[1]'])


    # degrees of freedom
    stat_args = check_output([
        # 3dAttribute BRICK_STATAUX ttest++_result+tlrc
        '3dAttribute', 'BRICK_STATAUX', resbrik])
    dof = int(stat_args.split()[-1])

    nidm['Contrasts'].append({
            # TODO: do we want specific names?
            "StatisticMap_contrastName": "group",
            "ContrastWeightMatrix_value": [1],
            "StatisticMap_statisticType": "obo_TStatistic",
            # degrees of freedom
            "StatisticMap_errorDegreesOfFreedom": dof,
            "StatisticMap_atLocation": "TStatistic.nii",
            # TODO inworldcoordsyst
            "StatisticMap_inWorldCoordinateSystem": "TODO",
            "ContrastMap_atLocation": "Contrast.nii",
            # TODO inworldcoordsyst
            "ContrastMap_inWorldCoordinateSystem": "TODO",
            # TODO ContrastStandardErrorMap_atLocation
            "ContrastStandardErrorMap_atLocation": "TODO"
        })
    # TODO connectivity criterion
    nidm['ClusterDefinitionCriteria_hasConnectivityCriterion'] = "TODO"
    # TODO PeakDefinitionCriteria_minDistanceBetweenPeaks
    nidm['PeakDefinitionCriteria_minDistanceBetweenPeaks'] = "TODO"
    # TODO PeakDefinitionCriteria_maxNumberOfPeaksPerCluster
    nidm['PeakDefinitionCriteria_maxNumberOfPeaksPerCluster'] = "TODO"

    print(json.dumps(nidm, indent=4))
