#!/usr/bin/python
"""
Export neuroimaging results created with FSL feat following NIDM-Results

DC code convergence
"""
import json
import sys
from subprocess import check_call, check_output
from collections import OrderedDict
import argparse
import itertools

# nidmjsonafni ttest++_result+tlrc.BRIK

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('-inset')
    parser.add_argument('-mask')
    parser.add_argument('-mask_from_hdr')
    parser.add_argument('-out_mask')
    parser.add_argument('-ithr')
    parser.add_argument('-idat')
    parser.add_argument('-1sided', nargs=2)
    parser.add_argument('-2sided')
    parser.add_argument('-bisided')
    parser.add_argument('-within_range')
    parser.add_argument('-NN')
    parser.add_argument('-clust_nvox')
    parser.add_argument('-clust_vol')
    parser.add_argument('-pref_map')
    parser.add_argument('-pref_dat')
    parser.add_argument('-1Dformat')
    parser.add_argument('-no_1Dformat')
    parser.add_argument('-summarize')
    parser.add_argument('-nosum')
    parser.add_argument('-quiet')
    parser.add_argument('-outvol_if_no_clust')
    parser.add_argument('-orient')
    parser.add_argument('-noabs')
    parser.add_argument('-binary')

    args = parser.parse_args()

    resbrik = args.inset

    nidm = OrderedDict()
    nidm['NeuroimagingAnalysisSoftware_type'] = "AFNI"

    ver = check_output([
        # afni --version
        'afni', '--version'])
    nidm['NeuroimagingAnalysisSoftware_softwareVersion'] = ver

    # TODO rethink in NIDM
    nidm['Data_grandMeanScaling'] = True
    nidm['Data_targetIntensity'] = 100

    # TODO design matrix
    nidm['DesignMatrix_atLocation'] = "TODO"
    nidm['DesignMatrix_regressorNames'] = ["group"]

    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[0]
        '3dAFNItoNIFTI', '-prefix', 'ParameterEstimate', resbrik + '[0]'])

    nidm['ParameterEstimateMaps'] = ["ParameterEstimate.nii"]

    nidm['ErrorModel_hasErrorDistribution'] = "obo_NormalDistribution"
    nidm['ErrorModel_errorVarianceHomogeneous'] = True
    # TODO: check
    nidm['ErrorModel_varianceMapWiseDependence'] = "nidm:IndependentParameter"
    nidm['ErrorModel_hasErrorDependence'] = "nidm:IndependentError"
    nidm['ErrorModel_depemdenceMapWiseDependence'] = "nidm_IndependentParameter"

    nidm['ModelParameterEstimation_withEstimationMethod'] = "obo_OrdinaryLeastSquaresEstimation"

    # TODO residualmeansquares
    nidm['ResidualMeanSquaresMap_atLocation'] = "TODO"
    # TODO GrandMeanMap --> not needed
    nidm['GrandMeanMap_atLocation'] = "TODO"
    nidm['MaskMap_atLocation'] = args.mask

    # TODO CoordinateSpace_inWorldCoordinateSystem
    nidm['CoordinateSpace_inWorldCoordinateSystem'] = "TODO"

    nidm['Contrasts'] = []
    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[0]
        '3dAFNItoNIFTI', '-prefix', 'Contrast', resbrik + '[0]'])
    check_call([
        # 3dAFNItoNIFTI -prefix <NAME> <RES_BRIK>[1]
        '3dAFNItoNIFTI', '-prefix', 'TStatistic', resbrik + '[1]'])


    # degrees of freedom
    stat_args = check_output([
        # 3dAttribute BRICK_STATAUX ttest++_result+tlrc
        '3dAttribute', 'BRICK_STATAUX', resbrik])
    dof = int(stat_args.split()[-1])

    nidm['Contrasts'].append({
            # TODO: do we want specific names?
            "StatisticMap_contrastName": "group",
            "ContrastWeightMatrix_value": [1],
            "StatisticMap_statisticType": "obo_TStatistic",
            # degrees of freedom
            "StatisticMap_errorDegreesOfFreedom": dof,
            "StatisticMap_atLocation": "TStatistic.nii",
            # TODO inworldcoordsyst
            "StatisticMap_inWorldCoordinateSystem": "TODO",
            "ContrastMap_atLocation": "Contrast.nii",
            # TODO inworldcoordsyst
            "ContrastMap_inWorldCoordinateSystem": "TODO",
            # TODO ContrastStandardErrorMap_atLocation
            "ContrastStandardErrorMap_atLocation": "TODO"
        })

    CONN_DICT = {
        '1': 6,
        '2': 18,
        '3': 26
    }

    nidm['ClusterDefinitionCriteria_hasConnectivityCriterion'] = \
        CONN_DICT[args.NN]
    # TODO PeakDefinitionCriteria_minDistanceBetweenPeaks
    nidm['PeakDefinitionCriteria_minDistanceBetweenPeaks'] = 2
    # TODO PeakDefinitionCriteria_maxNumberOfPeaksPerCluster
    nidm['PeakDefinitionCriteria_maxNumberOfPeaksPerCluster'] = 2

    print(json.dumps(nidm, indent=2))

    # Keep only arguments that were defined
    defined_args = {'-' + k: v for k, v in args._get_kwargs() if v is not None}
    # Transform into flat list with all defined key value pairs
    defined_args = list(itertools.chain(*defined_args.items()))
    # Flatten any list (multi value arguments)
    # TODO: could this be done with simpler syntax
    dargs = list()
    for aa in defined_args:
        if isinstance(aa, list):
            dargs.extend(aa)
        else:
            dargs.append(aa)

    print(['3dClusterize'] + dargs)
    check_call(['3dClusterize'] + dargs)
